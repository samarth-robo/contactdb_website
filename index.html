<!DOCTYPE html>
<html lang="en">
	<head>
		<title>ContactDB Explorer</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
      integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">    
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/PLYLoader.js"></script>
		<script src="js/WebGL.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="https://code.jquery.com/jquery-1.12.4.min.js"
      integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>


    <div class="container">
      <div class="row">
        <div class="col">
          <h1>ContactDB: Analyzing and Predicting Grasp Contact via Thermal Imaging</h1>
          <h2>
            <a href="https://samarth-robo.github.io/" target="_blank">Samarth Brahmbhatt</a>,
            <a href="https://cusuh.github.io/" target="_blank">Cusuh Ham</a>,
            <a href="http://ckemp.bme.gatech.edu/" target="_blank">Charlie Kemp</a>,
            <a href="https://www.cc.gatech.edu/~hays/" target="_blank">James Hays</a>
            <br>
            Georgia Tech Robotics
          </h2>
          ContactDB is a dataset of contact maps for household objects. Objects are grasped by human participants with two post-grasp functional intents: 'use' and 'handoff'.
        </div>
      </div>

      <div class="row align-items-center">
          <div class="col-5 align-self-center" id='controlsArea'></div>
          <div class="col-7 align-self-center">
            <canvas id="meshArea"></canvas>
          </div>
      </div>
      <footer>
        <script>
          var d = new Date();
          document.write('<p>&copy; Samarth Brahmbhatt ' + d.getFullYear() + ', website created using <a href="http://getbootstrap.com/" target="_blank">Bootstrap</a>.</p>')
        </script>
      </footer>
    </div>


		<script>

			if ( WEBGL.isWebGLAvailable() === false ) {

				document.body.appendChild( WEBGL.getWebGLErrorMessage() );

			}

			var camera, scene, renderer, controls, dLight, aLight, material, mesh, loader, meshName;
      var objectName, sessionName, instruction;
      var datapoints;

			init();

      
      function updateObjectNames() {
        // get instruction
        var instr = document.getElementById("instructions").value;

        // update the object names menu
        var menu = document.getElementById("objectNames");
        var prevObjectName = menu.value;
        menu.options.length = 0;
        var idxSelected = 0;
        for (var o in datapoints[instr]) {
          menu.options[menu.length] = new Option(o, o);
          if (o == prevObjectName) {
            idxSelected = menu.length - 1;
          }
        }
        menu.options[idxSelected].selected = true;
        menu.onchange(menu.value);
      }

      
      function updateSessionNames() {
        // get instruction and object name
        var instr = document.getElementById("instructions").value;
        var oName = document.getElementById("objectNames").value;

        // update the session names menu
        var menu = document.getElementById("sessionNames");
        var prevSessionName = menu.value;
        menu.options.length = 0;
        var idxSelected = 0;
        var sessionList = datapoints[instr][oName]
        for (var sIdx=0; sIdx < sessionList.length; sIdx++) {
          var s = sessionList[sIdx];
          menu.options[menu.length] = new Option(s, s);
          if (s == prevSessionName) {
            idxSelected = menu.length - 1;
          }
        }
        menu.options[idxSelected].selected = true;
        menu.onchange(menu.value);
      }


      function updateMenus(instructionSelected, objectNameSelected) {
        if (instructionSelected) {
          updateObjectNames();
        } else if (objectNameSelected) {
          updateSessionNames();
        }
      }


      function instructionChanged(value) {
        instruction = value;
        updateMenus(true, false);
        updateMesh();
      }
      function objectNameChanged(value) {
        objectName = value;
        updateMenus(false, true);
        updateMesh();
      }
      function sessionNameChanged(value) {
        sessionName = value;
        updateMesh();
      }

      
      function updateMesh() {
        var newMeshName = 'http://cayley.cc.gt.atl.ga.us/contactdb_dataset/meshes/full' + sessionName + '_' + instruction + '_' + objectName + '.ply';
        // var newMeshName = '../meshes/full' + sessionName + '_' + instruction + '_' + objectName + '.ply';
        if (newMeshName != meshName) {
          meshName = newMeshName;
          loader.load(meshName, onGeometryLoad);
        }
      }


      function createMenus(jsondata) {
        datapoints = {};
        for (var instr in jsondata) {
          datapoints[instr] = {};
          Object.keys(jsondata[instr]).sort().forEach(function(key) {
            datapoints[instr][key] = jsondata[instr][key];
          });
        }
        
        var controlsArea = document.getElementById('controlsArea');
        iMenu = document.createElement('select');
        iMenu.id = 'instructions';
        iMenu.setAttribute('onchange', 'instructionChanged(this.value)');
        controlsArea.appendChild(iMenu);
        
        oMenu = document.createElement('select');
        oMenu.id = 'objectNames';
        oMenu.setAttribute('onchange', 'objectNameChanged(this.value)');
        controlsArea.appendChild(oMenu);
        
        sMenu = document.createElement('select');
        sMenu.id = 'sessionNames';
        sMenu.setAttribute('onchange', 'sessionNameChanged(this.value)');
        controlsArea.appendChild(sMenu);
        
        for (var instr in datapoints) {
          iMenu.options[iMenu.length] = new Option(instr);
        }
        iMenu.options[0].selected = true;
        
        initRender();
        iMenu.onchange(iMenu.value);
        animate();
      }

      
      function initRender() {
				meshArea = document.getElementById('meshArea');

				camera = new THREE.PerspectiveCamera(60, 2, 0.01, 0.31);
				camera.position.set(0, -0.16, 0.1);
				var cameraTarget = new THREE.Vector3(0, 0, 0);
        camera.lookAt(cameraTarget);

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xFFFFFF );

				loader = new THREE.PLYLoader();

				// Lights
        dLight = new THREE.DirectionalLight(0xFFFFFF, 0.5);
        dLight.position.copy(camera.position);
        scene.add(dLight);

        aLight = new THREE.AmbientLight(0xFFFFFF, 0.77);
        scene.add(aLight);

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: true, canvas: meshArea } );
				renderer.setPixelRatio( window.devicePixelRatio );
        renderer.shadowMap.enabled = true;

        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 5.0;
        controls.addEventListener('change', render);

        material = new THREE.MeshStandardMaterial( { color: 'white', vertexColors: THREE.VertexColors } );
      }

			function init() {

        // read datapoints information and create dropdown menus
        var datapointsName = 'http://cayley.cc.gt.atl.ga.us/contactdb_dataset/datapoints.json';
        // var datapointsName = '../datapoints.json';
        $.getJSON(datapointsName, {}, createMenus);

			}

      function onGeometryLoad ( geometry ) {
        geometry.center();
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();

        if (mesh == null) {
          mesh = new THREE.Mesh( geometry, material );
          mesh.name = 'object';
          scene.add(mesh);
        } else {
          mesh.geometry.dispose()
          mesh.geometry = geometry;
        }
      }

			function resizeCanvas() {

        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height= canvas.clientHeight;

        if (canvas.width != width || canvas.height != height) {
          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        }

        controls.handleResize();
        render();

			}

      function render() {
        dLight.position.copy(camera.position);
				renderer.render( scene, camera );
      }

      function animate() {
        resizeCanvas();
				requestAnimationFrame( animate );
        controls.update();
        render();
			}


		</script>
	</body>
</html>
